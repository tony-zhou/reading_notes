# 第一章 Unix/Linux shell简介
## 1.1 Unix与Linux及其历史
### 1.1.1 Unix简介
* 一个多用户、多任务的操作系统

### 1.1.2 为什么选择Linux

## 1.2 shell的定义与功能
### 1.2.1 Unix shell
* Bourne shell
	* `用于系统管理，提示符: $` 
* C shell
	* `提示符: %` 
* Korn shell
	* `Bourne shell的扩展集，提示符: $`

### 1.2.2 Linux的shell
* GNU bash (Bourne Again shell)
	* `提示符: $` 
* TC shell
	* `提示符: >` 
* Z shell
	* `结合了Bourne Again shell、TC shell和Korn shell的许多功能`

## 1.3 shell的历史
### 1.3.1 shell的作用
* 在交互方式下解释从命令行输入的命令
* 定制用户环境，通常在shell的初始化文件中完成
* 解释性编程语言

### 1.3.2 shell的职责
* 读取输入并解释命令行
* 替换特殊字符，比如通配符和历史命令符
* 设置管道、重定向和后台处理
* 处理信号
* 程序执行的相关设置

## 1.4 系统启动与登录shell
* 系统启动运行时运行的第一个进程是init。每个进程都有一个称为PID的进程标识号。init是第一个进程，PID是1
* init进程初始化系统，启动另一个进程来打开终端线路并设置标准输入(stdin)，标准输出(stdout)和标准错误输出(stderr)，完成设置后，终端上出现登录提示
* 输入用户名后提示输入口令。程序/bin/login通过检查passwd文件的首字段来确认用户身份。如果所键入的用户名存在，它会运行一个密码程序来对所键入的口令进行确认。
* 口令验证通过后，login程序设置初始环境（一组工作环境的变量），这组变量将传给shell。变量HOME、SHELL、USER和LOGNAME根据passwd文件中的信息进行赋值
* shell启动后，先查找由系统管理员设置的系统级的初始化文件，然后在用户的主目录中查找是否存在对应的shell初始化文件。如果存在，就回执行这些文件，用户进一步定制用户环境

### 1.4.1 解析命令行
* 在命令提示符后输入一条命令后，shell会读入这个命令行并对命令行进行解析，将其分解为词(token)，token之间用空格或制表符分隔，命令行以换行符结尾。
* shell检查第一个词是否为内置命令或磁盘上的可执行程序。如果是内置命令，shell就在自己内部执行。否则，shell将在路径变量所指的目录中查找这个程序。如果找到了命令的程序，shell就创建一个进程来执行它。之后，shell进入睡眠（或等待）状态直至程序执行完毕。shell会根据需要报告程序的退出状态。
* 命令行处理顺序
	* 执行历史命令替代（视情况而定）
	* 命令行被分解为token
	* 更新历史命令（视情况而定）
	* 引用的处理
	* 别名替代和函数的定义（视情况而定）
	* 设置重定向，后台进程和管道
	* 执行变量替换（如$name，$user等）
	* 执行命令替换（如\`date\`代替Today）
	* 执行称为globbing的文件名替换（如cat abc.??, rm *.c等）
	* 执行命令

### 1.4.2 命令类型
* 执行命令前，shell按照如下顺序判定命令类型
	* 别名
	* 关键字
	* 函数
	* 内置命令
	* 可执行程序

## 1.5 进程与shell
* 进程是正在运行的程序，可以用它唯一的PID号来标识。内核负责控制和管理进程。进程由可执行程序、进程的数据和堆栈、程序指针和堆栈指针、寄存器以及程序运行时需要的所有信息组成

### 1.5.1 哪些程序正在运行
* `ps命令`
* `pstree/ptree命令`

### 1.5.2 系统调用
### 1.5.3 创建进程
* 系统调用fork
	* 在Unix系统中，进程是通过系统调用fork创建的。系统调用fork创建调用进程的一个副本。新创建的这个进程称为子进程(child)，创建它的进程称为父进程(parent)
	* fork调用完成后，子进程立即开始运行，最初阶段，父子进程共享CPU。子进程还将得到父进程信息的副本，包括环境、打开的文件、真实且有效的用户标识、umask、当前工作目录和信号
	* 用户输入命令后，shell开始解析命令行，判断第一个单词是内置命令还是磁盘上的可执行命令。如果是内置命令，就由shell来处理；如果是磁盘上的命令，shell就调用fork来生成自己的一个副本。子进程将搜索路径找到这个命令，并且设置用于重定向的文件描述符、管道、命令替换和后台处理。子shell运行时，父shell通常处于睡眠状态

* 系统调用wait
	* 当子进程处理重定向、管道和后台处理等细节时，父shell进入睡眠状态。系统调用wait导致父进程挂起直至它的一个子进程终止。
	* 如果wait调用成功，它将返回死去子进程的PID和子进程的退出状态。如果父进程没有等待，子进程死亡时就进入僵尸（假死）状态，并且保持这个状态直至父进程调用wait或死亡。如果父进程先于子进程死亡，则init进程会处理遗留的僵尸进程。
	* 系统调用wait不仅仅用于让父进程进入睡眠状态，还可用于保证进程正常终止。

* 系统调用exit
 	* 新程序随时可以通过调用exit终止。子进程终止时，会向父进程发出一个信号(sigchild)并等待父进程接受它的退出状态。退出状态是一个0 ~ 255之间的数。退出状态为0说明程序执行成功，不为0则表示发生了某种错误
 	* 查看上一条命令的退出状态
 		* C／TC shell： `echo $ status`
 		* Bourne, Bash, Korn shells：`echo $?`
 	* 进程可以通过Ctrl+C或Ctrl+\组合键，或者通过kill命令(内置shell命令)终止
 		* `kill pid`   

## 1.6 环境与继承
### 1.6.1 所有权
### 1.6.2 为文件创建掩码
### 1.6.3 修改权限与所有者
### 1.6.4 工作目录
### 1.6.5 变量
### 1.6.6 重定向与管道
### 1.6.7 shell和信号
